// Copyright (c) Microsoft Corporation. All rights reserved..
// Licensed under the MIT License.

use common::MmiError;
use daemonconfiguration::{DaemonConfiguration, Systemctl};
use libc::{c_char, c_int, c_uint, c_void, EINVAL};
use std::ffi::{CStr, CString};
use std::{ptr, slice};

mod common;
mod daemonconfiguration;

// Constants and Method headers were generated by bindgen
// (https://github.com/rust-lang/rust-bindgen)
pub const MMI_OK: i32 = 0;
pub type MmiHandle = *mut c_void;
pub type MmiJsonString = *mut c_char;

// MSFT change: Added the #[no_mangle] annotation, renamed
// parameters, and defined the methods
#[no_mangle]
pub extern "C" fn MmiGetInfo(
    client_name: *const c_char,
    payload: *mut MmiJsonString,
    payload_size_bytes: *mut c_int,
) -> c_int {
    if client_name.is_null() {
        println!("MmiGetInfo called with null clientName");
        EINVAL
    } else if payload.is_null() {
        println!("MmiGetInfo called with null payload");
        EINVAL
    } else if payload_size_bytes.is_null() {
        println!("MmiGetInfo called with null payloadSizeBytes");
        EINVAL
    } else {
        // Borrow the client_name ptr
        let client_name: &CStr = unsafe { CStr::from_ptr(client_name) };
        let result: Result<i32, MmiError> =
            mmi_get_info_helper(client_name, payload, payload_size_bytes);
        match result {
            Ok(code) => code,
            Err(e) => {
                println!("{}", e);
                let error_code: c_int = e.into();
                error_code
            }
        }
    }
}

fn mmi_get_info_helper(
    client_name: &CStr,
    payload: *mut MmiJsonString,
    payload_size_bytes: *mut c_int,
) -> Result<i32, MmiError> {
    // The question operator will either unwrap and continue or return an Err(MmiError)
    let client_name: &str = client_name.to_str()?;
    let info: &str = DaemonConfiguration::get_info(client_name)?;
    let payload_string: CString = CString::new(info)?;
    let payload_size = payload_string.as_bytes().len();
    let payload_ptr: MmiJsonString = CString::into_raw(payload_string);
    unsafe {
        *payload = payload_ptr;
        // .as_bytes() doesn't add a null terminator, so the payload size is correct
        *payload_size_bytes = payload_size as i32;
    }
    Ok(MMI_OK)
}

#[no_mangle]
pub extern "C" fn MmiOpen(client_name: *const c_char, max_payload_size_bytes: c_uint) -> MmiHandle {
    if client_name.is_null() {
        println!("MmiOpen called with null clientName");
        ptr::null_mut() as *mut c_void
    } else {
        let daemon_config_box: Box<DaemonConfiguration> =
            Box::<DaemonConfiguration>::new(DaemonConfiguration::new(max_payload_size_bytes));
        Box::into_raw(daemon_config_box) as *mut c_void
    }
}

#[no_mangle]
pub extern "C" fn MmiClose(client_session: MmiHandle) {
    if !client_session.is_null() {
        // The "_" variable name is to throwaway anything stored into it
        let _: Box<DaemonConfiguration> =
            unsafe { Box::from_raw(client_session as *mut DaemonConfiguration) };
    }
}

#[no_mangle]
pub extern "C" fn MmiSet(
    client_session: MmiHandle,
    component_name: *const c_char,
    object_name: *const c_char,
    payload: MmiJsonString,
    payload_size_bytes: c_int,
) -> c_int {
    if client_session.is_null() {
        println!("MmiSet called with null clientSession");
        EINVAL
    } else {
        let daemon_config: &mut DaemonConfiguration =
            unsafe { &mut *(client_session as *mut DaemonConfiguration) };
        let component_name: &CStr = unsafe { CStr::from_ptr(component_name) };
        let object_name: &CStr = unsafe { CStr::from_ptr(object_name) };
        // Payload is not null terminated so we may not use CString::from_ptr
        let payload: &[u8] =
            unsafe { slice::from_raw_parts(payload as *const u8, payload_size_bytes as usize) };
        let result: Result<i32, MmiError> =
            mmi_set_helper(daemon_config, component_name, object_name, payload);
        match result {
            Ok(code) => code,
            Err(e) => {
                println!("{}", e);
                let error_code: c_int = e.into();
                error_code
            }
        }
    }
}

fn mmi_set_helper(
    daemon_config: &mut DaemonConfiguration,
    component_name: &CStr,
    object_name: &CStr,
    payload: &[u8],
) -> Result<i32, MmiError> {
    let component_name: &str = component_name.to_str()?;
    let object_name: &str = object_name.to_str()?;
    let payload: CString = CString::new(payload)?;
    let payload_slice: &str = payload.as_c_str().to_str()?;
    daemon_config.set(component_name, object_name, payload_slice)
}

#[no_mangle]
pub extern "C" fn MmiGet(
    client_session: MmiHandle,
    component_name: *const c_char,
    object_name: *const c_char,
    payload: *mut MmiJsonString,
    payload_size_bytes: *mut c_int,
) -> c_int {
    if client_session.is_null() {
        println!("MmiGet called with null clientSession");
        EINVAL
    } else if payload_size_bytes.is_null() {
        println!("MmiGet called with Invalid payloadSizeBytes");
        EINVAL
    } else {
        let daemon_config: &DaemonConfiguration =
            unsafe { &*(client_session as *mut DaemonConfiguration) };
        let component_name: &CStr = unsafe { CStr::from_ptr(component_name) };
        let object_name: &CStr = unsafe { CStr::from_ptr(object_name) };
        let result: Result<i32, MmiError> = mmi_get_helper(
            daemon_config,
            component_name,
            object_name,
            payload,
            payload_size_bytes,
        );
        match result {
            Ok(code) => code,
            Err(e) => {
                println!("{}", e);
                let error_code: c_int = e.into();
                error_code
            }
        }
    }
}

fn mmi_get_helper(
    daemon_config: &DaemonConfiguration,
    component_name: &CStr,
    object_name: &CStr,
    payload: *mut MmiJsonString,
    payload_size_bytes: *mut c_int,
) -> Result<i32, MmiError> {
    let component_name: &str = component_name.to_str()?;
    let object_name: &str = object_name.to_str()?;
    let payload_string: String = daemon_config.get::<Systemctl>(component_name, object_name)?;
    let payload_string: CString = CString::new(payload_string)?;
    let payload_size = payload_string.as_bytes().len();
    let payload_ptr: MmiJsonString = CString::into_raw(payload_string);
    unsafe {
        *payload = payload_ptr;
        *payload_size_bytes = payload_size as i32;
    }
    Ok(MMI_OK)
}

#[no_mangle]
pub extern "C" fn MmiFree(payload: MmiJsonString) {
    if !payload.is_null() {
        let _ = unsafe { CString::from_raw(payload) };
    }
}
