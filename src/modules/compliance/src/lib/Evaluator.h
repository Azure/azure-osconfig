// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

#ifndef COMPLIANCE_EVALUATOR_H
#define COMPLIANCE_EVALUATOR_H

#include "ContextInterface.h"
#include "Indicators.h"
#include "Logging.h"
#include "MmiResults.h"
#include "Result.h"

#include <Optional.h>
#include <map>
#include <sstream>
#include <string>
#include <vector>

struct json_object_t;
struct json_value_t;

// Audit and remediation functions are declared using following macros, respectively.
// The first argument is the name of the procedure, eg ensureFilePermissions.
// Following arguments define the parameters to the procedure, each parameters encoded as a string with fields
// separated with ':' :
// <name>:<description>:<flags>:<pattern>
// All fields except for name are optional, can be left empty or ommited.
// - description is a textual description to be put in schema
// - flags - currently only one flag is supported, 'M' for mandatory parameters
// - pattern is a regex to validate the value of the parameter.
// examples:
// "myParameter:This is my parameter"
// "myOtherParameter:Another parameter, mandatory:M"
// "yetanotherparameter:This one is validated::^[0-9]+$"

#define AUDIT_FN(fn_name, parameters...)                                                                                                               \
    ::compliance::Result<::compliance::Status> Audit##fn_name(std::map<std::string, std::string> args, IndicatorsTree& indicators, ContextInterface& context)

#define REMEDIATE_FN(fn_name, parameters...)                                                                                                           \
    ::compliance::Result<::compliance::Status> Remediate##fn_name(std::map<std::string, std::string> args, IndicatorsTree& indicators, ContextInterface& context)

namespace compliance
{

class PayloadFormatter
{
public:
    virtual ~PayloadFormatter() = default;

    virtual Result<std::string> Format(const IndicatorsTree& indicators) const = 0;
};

class NestedListFormatter : public PayloadFormatter
{
    void FormatNode(const IndicatorsTree::Node& node, std::ostringstream& output, int depth) const;

public:
    ~NestedListFormatter() override = default;

    Result<std::string> Format(const IndicatorsTree& indicators) const override;
};

class CompactListFormatter : public PayloadFormatter
{
    void FormatNode(const IndicatorsTree::Node& node, std::ostringstream& output) const;

public:
    ~CompactListFormatter() override = default;

    Result<std::string> Format(const IndicatorsTree& indicators) const override;
};

class JsonFormatter : public PayloadFormatter
{
    Optional<Error> FormatNode(const IndicatorsTree::Node& node, json_value_t* jsonValue) const;

public:
    ~JsonFormatter() override = default;

    Result<std::string> Format(const IndicatorsTree& indicators) const override;
};

class MmiFormatter : public PayloadFormatter
{
    void FormatNode(const IndicatorsTree::Node& node, std::ostringstream& output) const;

public:
    ~MmiFormatter() override = default;
    Result<std::string> Format(const IndicatorsTree& indicators) const override;
};

using ParameterMap = std::map<std::string, std::string>;
using action_func_t = Result<Status> (*)(ParameterMap, IndicatorsTree&, ContextInterface&);
struct ProcedureActions
{
    action_func_t audit;
    action_func_t remediate;
};
using ProcedureMap = std::map<std::string, ProcedureActions>;

class Evaluator
{
public:
    Evaluator(std::string ruleName, const struct json_object_t* json, const ParameterMap& parameters, ContextInterface& context);
    ~Evaluator() = default;
    Evaluator(const Evaluator&) = delete;
    Evaluator(Evaluator&&) = delete;
    Evaluator& operator=(const Evaluator&) = delete;
    Evaluator& operator=(Evaluator&&) = delete;

    Result<AuditResult> ExecuteAudit(const PayloadFormatter& formatter);
    Result<Status> ExecuteRemediation();

private:
    enum class Action
    {
        Audit,
        Remediate
    };
    Result<Status> EvaluateProcedure(const struct json_object_t* object, Action action);
    Result<Status> EvaluateAnyOf(const struct json_value_t* value, Action action);
    Result<Status> EvaluateAllOf(const struct json_value_t* value, Action action);
    Result<Status> EvaluateNot(const struct json_value_t* value, Action action);
    Result<Status> EvaluateBuiltinProcedure(const std::string& procedureName, const struct json_value_t* value, Action action);
    Result<std::map<std::string, std::string>> GetBuiltinProcedureArguments(const json_value_t* value) const;
    const struct json_object_t* mJson;
    const ParameterMap& mParameters;
    ContextInterface& mContext;
    // autogenerated, instantiated in ProcedureMap.cpp
    static const ProcedureMap mProcedureMap;
    static const size_t cLogstreamMaxSize = 4096;

    // List of indicators which determine the final state of the evaluation
    IndicatorsTree mIndicators;
};
} // namespace compliance

#endif // COMPLIANCE_EVALUATOR_H
