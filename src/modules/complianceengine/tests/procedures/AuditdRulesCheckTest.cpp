// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

#include "Evaluator.h"
#include "MockContext.h"
#include "ProcedureMap.h"

#include <cstdio>
#include <cstdlib>
#include <fstream>
#include <gtest/gtest.h>
#include <map>
#include <string>
#include <unistd.h>
#include <vector>

namespace ComplianceEngine
{
// Forward declaration for the audit function under test (generated by AUDIT_FN in AuditdRulesCheck.cpp)
Result<Status> AuditAuditdRulesCheck(std::map<std::string, std::string> args, IndicatorsTree& indicators, ContextInterface& context);
} // namespace ComplianceEngine

using ComplianceEngine::AuditAuditdRulesCheck;
using ComplianceEngine::Error;
using ComplianceEngine::IndicatorsTree;
using ComplianceEngine::Result;
using ComplianceEngine::Status;
using ::testing::Return;

class AuditdRulesCheckTest : public ::testing::Test
{
protected:
    MockContext mContext;
    IndicatorsTree indicators;

    void SetUp() override
    {
        indicators.Push("AuditdRulesCheck");
        // Default UID_MIN for tests
        EXPECT_CALL(mContext, GetFileContents("/etc/login.defs")).WillRepeatedly(Return(Result<std::string>(std::string("UID_MIN 1000\n"))));
    }

    static std::string MakeTempDir()
    {
        char tmpl[] = "/tmp/auditrulesXXXXXX";
        char* d = mkdtemp(tmpl);
        return d ? std::string(d) : std::string();
    }

    static void WriteFile(const std::string& path, const std::string& content)
    {
        std::ofstream ofs(path);
        ofs << content;
        ofs.close();
    }

    static void RemoveFile(const std::string& path)
    {
        std::remove(path.c_str());
    }

    static void RemoveDir(const std::string& path)
    {
        rmdir(path.c_str());
    }
};

// Test missing searchItem parameter
TEST_F(AuditdRulesCheckTest, MissingSearchItemReturnsError)
{
    std::map<std::string, std::string> args;
    args["requiredOptions"] = "-p wa";

    auto result = AuditAuditdRulesCheck(args, indicators, mContext);
    ASSERT_FALSE(result.HasValue());
}

// Test missing requiredOptions parameter
TEST_F(AuditdRulesCheckTest, MissingRequiredOptionsReturnsError)
{
    std::map<std::string, std::string> args;
    args["searchItem"] = "-w /etc/sudoers";

    auto result = AuditAuditdRulesCheck(args, indicators, mContext);
    ASSERT_FALSE(result.HasValue());
}

// Test invalid requiredOptions regex
TEST_F(AuditdRulesCheckTest, InvalidRequiredOptionsRegexReturnsError)
{
    std::map<std::string, std::string> args;
    args["searchItem"] = "-w /etc/sudoers";
    args["requiredOptions"] = "(invalid"; // unbalanced paren

    auto result = AuditAuditdRulesCheck(args, indicators, mContext);
    ASSERT_FALSE(result.HasValue());
}

// Test invalid excludeOptions regex
TEST_F(AuditdRulesCheckTest, InvalidExcludeOptionsRegexReturnsError)
{
    std::map<std::string, std::string> args;
    args["searchItem"] = "-w /etc/sudoers";
    args["requiredOptions"] = "-p wa";
    args["excludeOption"] = "[*"; // invalid regex

    auto result = AuditAuditdRulesCheck(args, indicators, mContext);
    ASSERT_FALSE(result.HasValue());
}

// Test auditctl -l command fails
TEST_F(AuditdRulesCheckTest, AuditctlCommandFails)
{
    EXPECT_CALL(mContext, ExecuteCommand("auditctl -l")).WillOnce(Return(Result<std::string>(Error("Command execution failed", -1))));

    std::map<std::string, std::string> args;
    args["searchItem"] = "-w /etc/sudoers";
    args["requiredOptions"] = "-p wa";

    auto result = AuditAuditdRulesCheck(args, indicators, mContext);
    ASSERT_FALSE(result.HasValue());
}

// Test: override audit rules path with a temp directory containing matching rule -> Compliant
TEST_F(AuditdRulesCheckTest, OverridePathWithMatchingFileRuleIsCompliant)
{
    // Running config has matching rule
    EXPECT_CALL(mContext, ExecuteCommand("auditctl -l")).WillOnce(Return(Result<std::string>(std::string("-w /etc/sudoers -p wa\n"))));

    std::string dir = MakeTempDir();
    ASSERT_FALSE(dir.empty());
    std::string file = dir + "/test.rules";
    WriteFile(file, "# sample\n-w /etc/sudoers -p wa\n");
    mContext.SetSpecialFilePath("/etc/audit/rules.d", dir);

    std::map<std::string, std::string> args;
    args["searchItem"] = "-w /etc/sudoers";
    args["requiredOptions"] = "-p wa";

    auto result = AuditAuditdRulesCheck(args, indicators, mContext);

    // cleanup
    RemoveFile(file);
    RemoveDir(dir);

    ASSERT_TRUE(result.HasValue());
    ASSERT_EQ(result.Value(), Status::Compliant);
}

// Test: override path where running has rule but files do not -> NonCompliant
TEST_F(AuditdRulesCheckTest, OverridePathMissingFileRuleIsNonCompliant)
{
    EXPECT_CALL(mContext, ExecuteCommand("auditctl -l")).WillOnce(Return(Result<std::string>(std::string("-w /etc/sudoers -p wa\n"))));

    std::string dir = MakeTempDir();
    ASSERT_FALSE(dir.empty());
    std::string file = dir + "/test.rules";
    WriteFile(file, "# unrelated rule\n-w /var/log/auth.log -p wa\n");
    mContext.SetSpecialFilePath("/etc/audit/rules.d", dir);

    std::map<std::string, std::string> args;
    args["searchItem"] = "-w /etc/sudoers";
    args["requiredOptions"] = "-p wa";

    auto result = AuditAuditdRulesCheck(args, indicators, mContext);

    // cleanup
    RemoveFile(file);
    RemoveDir(dir);

    ASSERT_TRUE(result.HasValue());
    ASSERT_EQ(result.Value(), Status::NonCompliant);
}

// Test: invalid override path returns error when directory cannot be opened
TEST_F(AuditdRulesCheckTest, InvalidOverridePathReturnsError)
{
    EXPECT_CALL(mContext, ExecuteCommand("auditctl -l")).WillOnce(Return(Result<std::string>(std::string("No rules\n"))));
    mContext.SetSpecialFilePath("/etc/audit/rules.d", "/does/not/exist");

    std::map<std::string, std::string> args;
    args["searchItem"] = "-w /etc/sudoers";
    args["requiredOptions"] = "-p wa";

    auto result = AuditAuditdRulesCheck(args, indicators, mContext);
    ASSERT_FALSE(result.HasValue());
}

// Test: syscall search compliant when both running and files match
TEST_F(AuditdRulesCheckTest, SyscallSearchCompliantWithOverridePath)
{
    EXPECT_CALL(mContext, ExecuteCommand("auditctl -l"))
        .WillOnce(Return(Result<std::string>(std::string("-S mount -F arch=b64 -a always,exit -F auid>=1000 -F auid!=4294967295\n"))));

    std::string dir = MakeTempDir();
    ASSERT_FALSE(dir.empty());
    std::string file = dir + "/sys.rules";
    WriteFile(file, "-S mount -F arch=b64 -a always,exit -F auid>=1000 -F auid!=4294967295\n");
    mContext.SetSpecialFilePath("/etc/audit/rules.d", dir);

    std::map<std::string, std::string> args;
    args["searchItem"] = "-S mount";
    args["requiredOptions"] = "-F arch=b64:-a (always,exit|exit,always):-F auid>=123:-F auid!=(unset|-1|4294967295)";

    auto result = AuditAuditdRulesCheck(args, indicators, mContext);

    RemoveFile(file);
    RemoveDir(dir);

    ASSERT_TRUE(result.HasValue());
    ASSERT_EQ(result.Value(), Status::Compliant);
}

// Test: syscall search non-compliant when files missing required rule
TEST_F(AuditdRulesCheckTest, SyscallSearchFilesMissingIsNonCompliant)
{
    EXPECT_CALL(mContext, ExecuteCommand("auditctl -l"))
        .WillOnce(Return(Result<std::string>(std::string("-S mount -F arch=b64 -a always,exit -F auid>=1000 -F auid!=4294967295\n"))));

    std::string dir = MakeTempDir();
    ASSERT_FALSE(dir.empty());
    std::string file = dir + "/sys.rules";
    WriteFile(file, "# unrelated syscall\n-S umount -F arch=b64 -a always,exit -F auid>=1000 -F auid!=4294967295\n");
    mContext.SetSpecialFilePath("/etc/audit/rules.d", dir);

    std::map<std::string, std::string> args;
    args["searchItem"] = "-S mount";
    args["requiredOptions"] = "-F arch=b64:-a (always,exit|exit,always):-F auid>=123:-F auid!=(unset|-1|4294967295)";

    auto result = AuditAuditdRulesCheck(args, indicators, mContext);

    RemoveFile(file);
    RemoveDir(dir);

    ASSERT_TRUE(result.HasValue());
    ASSERT_EQ(result.Value(), Status::NonCompliant);
}

// Test: multi-syscall search where one missing in files -> NonCompliant
TEST_F(AuditdRulesCheckTest, MultiSyscallOneMissingInFilesIsNonCompliant)
{
    EXPECT_CALL(mContext, ExecuteCommand("auditctl -l"))
        .WillOnce(Return(Result<std::string>(std::string("-S mount -F arch=b64 -a always,exit -F auid>=1000 -F auid!=4294967295\n"
                                                         "-S umount -F arch=b64 -a always,exit -F auid>=1000 -F auid!=4294967295\n"))));

    std::string dir = MakeTempDir();
    ASSERT_FALSE(dir.empty());
    std::string file = dir + "/sys.rules";
    // Only mount present in files, umount missing
    WriteFile(file, "-S mount -F arch=b64 -a always,exit -F auid>=1000 -F auid!=4294967295\n");
    mContext.SetSpecialFilePath("/etc/audit/rules.d", dir);

    std::map<std::string, std::string> args;
    args["searchItem"] = "-S mount,umount";
    args["requiredOptions"] = "-F arch=b64:-a (always,exit|exit,always):-F auid>=123:-F auid!=(unset|-1|4294967295)";

    auto result = AuditAuditdRulesCheck(args, indicators, mContext);

    RemoveFile(file);
    RemoveDir(dir);

    ASSERT_TRUE(result.HasValue());
    ASSERT_EQ(result.Value(), Status::NonCompliant);
}

// Test: excludeOptions causes matching rules to be ignored leading to NonCompliant
TEST_F(AuditdRulesCheckTest, ExcludeOptionsSkipsMatchingRules)
{
    EXPECT_CALL(mContext, ExecuteCommand("auditctl -l")).WillOnce(Return(Result<std::string>(std::string("-w /var/log/secure -p wa -k badkey\n"))));

    std::string dir = MakeTempDir();
    ASSERT_FALSE(dir.empty());
    std::string file = dir + "/watch.rules";
    WriteFile(file, "-w /var/log/secure -p wa -k badkey\n");
    mContext.SetSpecialFilePath("/etc/audit/rules.d", dir);

    std::map<std::string, std::string> args;
    args["searchItem"] = "-w /var/log/secure";
    args["requiredOptions"] = "-p wa";
    args["excludeOption"] = "-k badkey";

    auto result = AuditAuditdRulesCheck(args, indicators, mContext);

    RemoveFile(file);
    RemoveDir(dir);

    ASSERT_TRUE(result.HasValue());
    ASSERT_EQ(result.Value(), Status::NonCompliant);
}

// Test: SUDOLOGFILE resolved via sudoers with quotes, compliant when both present
TEST_F(AuditdRulesCheckTest, SudoLogfileCompliantWithOverridePath)
{
    EXPECT_CALL(mContext, ExecuteCommand("grep -E '^[[:space:]]*[Dd]efaults.*logfile' /etc/sudoers 2>/dev/null | tail -1"))
        .WillOnce(Return(Result<std::string>(std::string("Defaults logfile=\"/var/log/sudo/test.log\"\n"))));
    EXPECT_CALL(mContext, ExecuteCommand("grep -h -E '^[[:space:]]*[Dd]efaults.*logfile' /etc/sudoers.d/* 2>/dev/null | tail -1"))
        .WillRepeatedly(Return(Result<std::string>(std::string(""))));
    EXPECT_CALL(mContext, ExecuteCommand("auditctl -l")).WillOnce(Return(Result<std::string>(std::string("-w /var/log/sudo/test.log -p wa\n"))));

    std::string dir = MakeTempDir();
    ASSERT_FALSE(dir.empty());
    std::string file = dir + "/sudo.rules";
    WriteFile(file, "-w /var/log/sudo/test.log -p wa\n");
    mContext.SetSpecialFilePath("/etc/audit/rules.d", dir);

    std::map<std::string, std::string> args;
    args["searchItem"] = "SUDOLOGFILE";
    args["requiredOptions"] = "-p wa";

    auto result = AuditAuditdRulesCheck(args, indicators, mContext);

    RemoveFile(file);
    RemoveDir(dir);

    ASSERT_TRUE(result.HasValue());
    ASSERT_EQ(result.Value(), Status::Compliant);
}

// Test: SUDOLOGFILE non-compliant when file rule missing
TEST_F(AuditdRulesCheckTest, SudoLogfileFilesMissingIsNonCompliant)
{
    EXPECT_CALL(mContext, ExecuteCommand("grep -E '^[[:space:]]*[Dd]efaults.*logfile' /etc/sudoers 2>/dev/null | tail -1"))
        .WillOnce(Return(Result<std::string>(std::string("Defaults logfile=/var/log/audit/sudolog-test.log\n"))));
    EXPECT_CALL(mContext, ExecuteCommand("grep -h -E '^[[:space:]]*[Dd]efaults.*logfile' /etc/sudoers.d/* 2>/dev/null | tail -1"))
        .WillRepeatedly(Return(Result<std::string>(std::string(""))));
    EXPECT_CALL(mContext, ExecuteCommand("auditctl -l"))
        .WillOnce(Return(Result<std::string>(std::string("-w /var/log/audit/sudolog-test.log -p wa\n"))));

    std::string dir = MakeTempDir();
    ASSERT_FALSE(dir.empty());
    std::string file = dir + "/sudo.rules";
    WriteFile(file, "# no sudo logfile watch here\n");
    mContext.SetSpecialFilePath("/etc/audit/rules.d", dir);

    std::map<std::string, std::string> args;
    args["searchItem"] = "SUDOLOGFILE";
    args["requiredOptions"] = "-p wa";

    auto result = AuditAuditdRulesCheck(args, indicators, mContext);

    RemoveFile(file);
    RemoveDir(dir);

    ASSERT_TRUE(result.HasValue());
    ASSERT_EQ(result.Value(), Status::NonCompliant);
}

// Test: immutable rule (-e 2) compliant when present in files
TEST_F(AuditdRulesCheckTest, ImmutableRuleCompliant)
{
    EXPECT_CALL(mContext, ExecuteCommand("auditctl -l")).WillOnce(Return(Result<std::string>(std::string("No rules\n"))));

    std::string dir = MakeTempDir();
    ASSERT_FALSE(dir.empty());
    std::string file = dir + "/immutable.rules";
    WriteFile(file, "-e 2\n");
    mContext.SetSpecialFilePath("/etc/audit/rules.d", dir);

    std::map<std::string, std::string> args;
    args["searchItem"] = "-e 2";
    args["requiredOptions"] = ".*"; // allow any content for this simple line

    auto result = AuditAuditdRulesCheck(args, indicators, mContext);

    RemoveFile(file);
    RemoveDir(dir);

    ASSERT_TRUE(result.HasValue());
    ASSERT_EQ(result.Value(), Status::Compliant);
}

// Test: immutable rule (-e 2) non-compliant when missing in files
TEST_F(AuditdRulesCheckTest, ImmutableRuleMissingIsNonCompliant)
{
    EXPECT_CALL(mContext, ExecuteCommand("auditctl -l")).WillOnce(Return(Result<std::string>(std::string("No rules\n"))));

    std::string dir = MakeTempDir();
    ASSERT_FALSE(dir.empty());
    std::string file = dir + "/immutable.rules";
    WriteFile(file, "# empty file, no -e 2\n");
    mContext.SetSpecialFilePath("/etc/audit/rules.d", dir);

    std::map<std::string, std::string> args;
    args["searchItem"] = "-e 2";
    args["requiredOptions"] = ".*";

    auto result = AuditAuditdRulesCheck(args, indicators, mContext);

    RemoveFile(file);
    RemoveDir(dir);

    ASSERT_TRUE(result.HasValue());
    ASSERT_EQ(result.Value(), Status::NonCompliant);
}

// Test: running rule present but missing required options -> NonCompliant even if files have proper rule
TEST_F(AuditdRulesCheckTest, RunningRuleMissingRequiredOptionsIsNonCompliant)
{
    EXPECT_CALL(mContext, ExecuteCommand("auditctl -l")).WillOnce(Return(Result<std::string>(std::string("-w /etc/sudoers -p w\n"))));

    std::string dir = MakeTempDir();
    ASSERT_FALSE(dir.empty());
    std::string file = dir + "/watch.rules";
    WriteFile(file, "-w /etc/sudoers -p wa\n");
    mContext.SetSpecialFilePath("/etc/audit/rules.d", dir);

    std::map<std::string, std::string> args;
    args["searchItem"] = "-w /etc/sudoers";
    args["requiredOptions"] = "-p wa";

    auto result = AuditAuditdRulesCheck(args, indicators, mContext);

    RemoveFile(file);
    RemoveDir(dir);

    ASSERT_TRUE(result.HasValue());
    ASSERT_EQ(result.Value(), Status::NonCompliant);
}

// Test: running rules empty but files contain matching rule -> NonCompliant (running checked first)
TEST_F(AuditdRulesCheckTest, RunningRulesEmptyButFileMatchesIsNonCompliant)
{
    EXPECT_CALL(mContext, ExecuteCommand("auditctl -l")).WillOnce(Return(Result<std::string>(std::string("No rules\n"))));

    std::string dir = MakeTempDir();
    ASSERT_FALSE(dir.empty());
    std::string file = dir + "/watch.rules";
    WriteFile(file, "-w /etc/sudoers -p wa\n");
    mContext.SetSpecialFilePath("/etc/audit/rules.d", dir);

    std::map<std::string, std::string> args;
    args["searchItem"] = "-w /etc/sudoers";
    args["requiredOptions"] = "-p wa";

    auto result = AuditAuditdRulesCheck(args, indicators, mContext);

    RemoveFile(file);
    RemoveDir(dir);

    ASSERT_TRUE(result.HasValue());
    ASSERT_EQ(result.Value(), Status::NonCompliant);
}

// Test: SUDOLOGFILE not found in sudoers or sudoers.d -> returns Error
TEST_F(AuditdRulesCheckTest, SudoLogfileNotFoundReturnsError)
{
    EXPECT_CALL(mContext, ExecuteCommand("grep -E '^[[:space:]]*[Dd]efaults.*logfile' /etc/sudoers 2>/dev/null | tail -1"))
        .WillOnce(Return(Result<std::string>(std::string(""))));
    EXPECT_CALL(mContext, ExecuteCommand("grep -h -E '^[[:space:]]*[Dd]efaults.*logfile' /etc/sudoers.d/* 2>/dev/null | tail -1"))
        .WillOnce(Return(Result<std::string>(std::string(""))));
    EXPECT_CALL(mContext, ExecuteCommand("auditctl -l")).WillOnce(Return(Result<std::string>(std::string("No rules\n"))));

    std::string dir = MakeTempDir();
    ASSERT_FALSE(dir.empty());
    mContext.SetSpecialFilePath("/etc/audit/rules.d", dir);

    std::map<std::string, std::string> args;
    args["searchItem"] = "SUDOLOGFILE";
    args["requiredOptions"] = "-p wa";

    auto result = AuditAuditdRulesCheck(args, indicators, mContext);

    RemoveDir(dir);

    ASSERT_FALSE(result.HasValue());
}
