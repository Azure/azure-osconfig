use libc::{c_int, c_char ,c_void};//, c_void
use std::ffi::CStr;
use std::ffi::CString;
use std::ptr::NonNull;

mod sample;

// Constants and Method headers were generated by bindgen
// (https://github.com/rust-lang/rust-bindgen)
pub const MMI_OK: u32 = 0;
pub type MMI_HANDLE = *mut ::std::os::raw::c_void;
pub type MMI_JSON_STRING = *mut ::std::os::raw::c_char;

// MSFT change: Added the #[no_mangle] annotation and defined the methods
#[no_mangle]
pub extern "C" fn MmiGetInfo(
        clientName: *const ::std::os::raw::c_char,
        payload: *mut MMI_JSON_STRING,
        payloadSizeBytes: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
    let c_str: &CStr = unsafe { CStr::from_ptr(clientName) };
    let str_slice: &str = c_str.to_str().unwrap();
    println!("{}",str_slice);
    // Dereferencing a pointer
    unsafe{*payloadSizeBytes = 5};
    // Converting a string to a c_char pointer
    unsafe{let temppayload = CString::new("newpayload").unwrap();
    *payload= CString::into_raw(temppayload);}
    // Dummy return
    return 0;
}

#[no_mangle]
pub extern "C" fn MmiOpen(
        clientName: *const ::std::os::raw::c_char,
        maxPayloadSizeBytes: ::std::os::raw::c_uint,
    ) -> MMI_HANDLE {
    // let sample = sample::Sample({})
    let c_str: &CStr = unsafe { CStr::from_ptr(clientName) };
    let str_slice: &str = c_str.to_str().unwrap();
    println!("Client_name: {}",str_slice);
    println!("{}", maxPayloadSizeBytes);
    let mut vec = vec![1, 2, 3];
    let result =  vec.as_mut_ptr() as *mut _ as *mut c_void;
    return result;
}

#[no_mangle]
pub extern "C" fn MmiClose(clientSession: MMI_HANDLE){
    return;
}

#[no_mangle]
pub extern "C" fn MmiSet(
        clientSession: MMI_HANDLE,
        componentName: *const ::std::os::raw::c_char,
        objectName: *const ::std::os::raw::c_char,
        payload: MMI_JSON_STRING,
        payloadSizeBytes: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
    return 0;
}

#[no_mangle]
pub extern "C" fn MmiGet(
        clientSession: MMI_HANDLE,
        componentName: *const ::std::os::raw::c_char,
        objectName: *const ::std::os::raw::c_char,
        payload: *mut MMI_JSON_STRING,
        payloadSizeBytes: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
    return 0;
}

#[no_mangle]
pub extern "C" fn MmiFree(payload: MMI_JSON_STRING) {
    return;
}

// #[derive(Clone, Copy)]
// struct Number {
//     odd: bool,
//     value: i32,
// }

// impl std::clone::Clone for Number {
//     fn clone(&self) -> Self {
//         Self { ..*self }
//     }
// }

// impl Number {
//     fn is_strictly_positive(self) -> bool {
//         self.value > 0
//     }
// }


// #[no_mangle]
// pub extern "C" fn hello_from_rust() {
//     println!("Hello from Rust!");
// }

// #[no_mangle]
// pub extern "C" fn MmiGetInfo(
//         _client_name: *const libc::c_char ,
//         _payload: *mut *const libc::c_char,
//         _payload_size_bytes: *mut c_int) -> c_int 
//     {
//     // Converting a const c_char pointer to a Rust str reference
//     let c_str: &CStr = unsafe { CStr::from_ptr(_client_name) };
//     let str_slice: &str = c_str.to_str().unwrap();
//     println!("{}",str_slice);
//     // Dereferencing a pointer
//     unsafe{*_payload_size_bytes = 5};
//     // Converting a string to a c_char pointer
//     unsafe{let payload = CString::new("newpayload").unwrap();
//     *_payload= CString::into_raw(payload);}
//     // Dummy return
//     return 3;
// }

// #[no_mangle]
// pub extern "C" fn MmiOpen(
//         _client_name: *const libc::c_char ,
//         _max_payload_size_bytes: u32 ) -> c_void 
//     {
//     let c_str: &CStr = unsafe { CStr::from_ptr(_client_name) };
//     let str_slice: &str = c_str.to_str().unwrap();
//     println!("Client_name: {}",str_slice);
//     println!("{}", _max_payload_size_bytes);
//     let mut vec = vec![1, 2, 3];
//     let result =  vec.as_mut_ptr() as *mut c_void;
//     return *result;
// }

