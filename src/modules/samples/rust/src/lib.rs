// Copyright (c) Microsoft Corporation. All rights reserved..
// Licensed under the MIT License.

use libc::{c_char, c_int, c_uint, c_void, EINVAL, ENOMEM};
use sample::Sample;
use std::error::Error as StdError;
use std::ffi::{CStr, CString, NulError};
use std::fmt;
use std::ptr;
use std::str::Utf8Error;

mod sample;

// Constants and Method headers were generated by bindgen
// (https://github.com/rust-lang/rust-bindgen)
pub const MMI_OK: i32 = 0;
pub type MmiHandle = *mut c_void;
pub type MmiJsonString = *mut c_char;

#[derive(Debug)]
enum MmiError {
    FailedRead(Utf8Error),
    Code(i32),
    FailedAllocate(NulError),
}
impl From<Utf8Error> for MmiError {
    fn from(err: Utf8Error) -> MmiError {
        MmiError::FailedRead(err)
    }
}
impl From<i32> for MmiError {
    fn from(err: i32) -> MmiError {
        MmiError::Code(err)
    }
}
impl From<NulError> for MmiError {
    fn from(err: NulError) -> MmiError {
        MmiError::FailedAllocate(err)
    }
}
impl fmt::Display for MmiError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match &*self {
            MmiError::FailedRead(_e) => write!(f, "A read failed"),
            MmiError::Code(e) => write!(f, "There was C Error code {}", e),
            MmiError::FailedAllocate(_e) => write!(f, "A memory allocation failed"),
        }
    }
}
impl StdError for MmiError {
    fn description(&self) -> &str {
        match &*self {
            MmiError::FailedRead(_e) => "A read failed",
            MmiError::Code(_e) => "A C Error code",
            MmiError::FailedAllocate(_e) => "A memory allocation failed",
        }
    }
}

// MSFT change: Added the #[no_mangle] annotation, renamed
// parameters, and defined the methods
#[no_mangle]
pub extern "C" fn MmiGetInfo(
    client_name: *const c_char,
    payload: *mut MmiJsonString,
    payload_size_bytes: *mut c_int,
) -> c_int {
    if client_name.is_null() {
        println!("MmiGetInfo called with null clientName");
        EINVAL
    } else if payload.is_null() {
        println!("MmiGetInfo called with null payload");
        EINVAL
    } else if payload_size_bytes.is_null() {
        println!("MmiGetInfo called with null payloadSizeBytes");
        EINVAL
    } else {
        // Borrow the client_name ptr
        let client_name_cstr: &CStr = unsafe { CStr::from_ptr(client_name) };
        let result: Result<i32, MmiError> =
            mmi_get_info_helper(client_name_cstr, payload, payload_size_bytes);
        match result {
            Ok(code) => code,
            Err(MmiError::FailedRead(_e)) => {
                println!("MmiGetInfo failed to read the clientName");
                EINVAL
            }
            Err(MmiError::Code(e)) => e,
            Err(MmiError::FailedAllocate(_e)) => {
                println!("MmiGetInfo failed to allocate memory");
                ENOMEM
            }
        }
    }
}

fn mmi_get_info_helper(
    client_name_cstr: &CStr,
    payload: *mut MmiJsonString,
    payload_size_bytes: *mut c_int,
) -> Result<i32, MmiError> {
    // The question operator will either unwrap and continue or return an Err(MmiError)
    let client_name_str_slice = client_name_cstr.to_str()?;
    let info_str_slice = Sample::get_info(client_name_str_slice)?;
    let payload_string = CString::new(info_str_slice)?;
    let payload_ptr: MmiJsonString = CString::into_raw(payload_string);
    unsafe {
        *payload = payload_ptr;
        *payload_size_bytes = info_str_slice.len() as i32;
    }
    Ok(MMI_OK)
}

#[no_mangle]
pub extern "C" fn MmiOpen(client_name: *const c_char, max_payload_size_bytes: c_uint) -> MmiHandle {
    if client_name.is_null() {
        println!("MmiOpen called with null clientName");
        ptr::null_mut() as *mut c_void
    } else {
        let sample_box: Box<Sample> = Box::<Sample>::new(Sample::new(max_payload_size_bytes));
        Box::into_raw(sample_box) as *mut c_void
    }
}

#[no_mangle]
pub extern "C" fn MmiClose(client_session: MmiHandle) {
    if !client_session.is_null() {
        // The "_" variable name is to throwaway anything stored into it
        let _: Box<Sample> = unsafe { Box::from_raw(client_session as *mut Sample) };
    }
}

#[no_mangle]
pub extern "C" fn MmiSet(
    client_session: MmiHandle,
    component_name: *const c_char,
    object_name: *const c_char,
    payload: MmiJsonString,
    payload_size_bytes: c_int,
) -> c_int {
    unimplemented!("MmiSet is not yet implemented");
}

#[no_mangle]
pub extern "C" fn MmiGet(
    client_session: MmiHandle,
    component_name: *const c_char,
    object_name: *const c_char,
    payload: *mut MmiJsonString,
    payload_size_bytes: *mut c_int,
) -> c_int {
    unimplemented!("MmiGet is not yet implemented");
}

#[no_mangle]
pub extern "C" fn MmiFree(payload: MmiJsonString) {
    unimplemented!("MmiFree is not yet implemented");
}
