# Packaging pipeline - produces amd64 packages for:
#  - Debian 9
#  - Ubuntu 18.04
#  - Ubuntu 20.04

name: $(MajorVersion).$(MinorVersion).$(PatchVersion).$(Date:yyyyMMdd)$(Rev:rr)

resources:
  containers:
  - container: ubuntu18.04
    type: ACR
    azureSubscription: OSConfig-ACR
    endpoint: OSConfig-ACR
    resourceGroup: osconfig
    registry: osconfig
    repository: ubuntu18.04-dev
    image: osconfig.azurecr.io/ubuntu18.04-dev

  - container: ubuntu20.04
    type: ACR
    azureSubscription: OSConfig-ACR
    endpoint: OSConfig-ACR
    resourceGroup: osconfig
    registry: osconfig.azurecr.io
    repository: ubuntu20.04-dev
    image: osconfig.azurecr.io/ubuntu20.04-dev

  - container: debian9
    type: ACR
    azureSubscription: OSConfig-ACR
    endpoint: OSConfig-ACR
    resourceGroup: osconfig
    registry: osconfig.azurecr.io
    repository: debian9-dev
    image: osconfig.azurecr.io/debian9-dev

variables:
  OSCONFIG_SRC: $(Build.SourcesDirectory)/src
  OSCONFIG_VERSION: $(MajorVersion).$(MinorVersion).$(PatchVersion)

trigger:
  branches:
    include:
    - main
pr: none

strategy:
  matrix:
    Code Coverage:
      variant: ubuntu20.04
      arch: amd64
      poolName:
      vmImage: 'ubuntu-20.04'
      coverage: true
    Packaging ubuntu20-amd64:
      variant: ubuntu20.04
      arch: amd64
      poolName:
      vmImage: 'ubuntu-20.04'
      coverage: false
    Packaging ubuntu18-amd64:
      variant: ubuntu18.04
      arch: amd64
      poolName:
      vmImage: 'ubuntu-20.04'
      coverage: false
    Packaging debian9-amd64:
      variant: debian9
      arch: amd64
      poolName:
      vmImage: 'ubuntu-20.04'
      coverage: false

pool:
  name: $(poolName)
  vmImage: $(vmImage)

container: $[ variables['variant'] ]

workspace:
  clean: all

steps:
- checkout: self
  submodules: recursive
  persistCredentials: true
  clean: true

# Build the version string
- script: |
    echo Build number: $(Build.BuildNumber)
    OSCONFIG_REVISION=`echo "$(Build.BuildNumber)" | rev | cut -d . -f 1 | rev`
    echo Build prefix: $OSCONFIG_REVISION
    echo "##vso[task.setvariable variable=OSCONFIG_REVISION;]$OSCONFIG_REVISION"
  displayName: Build version string

# Run CMake to generate Makefile
- task: CMake@1
  displayName: 'Generate build'
  condition: eq(variables.coverage, false)
  inputs:
    workingDirectory: $(OSCONFIG_SRC)
    cmakeArgs: '-DCMAKE_BUILD_TYPE=Release -Duse_prov_client=ON -Dhsm_type_symm_key=ON -DCOMPILE_WITH_STRICTNESS=ON -DMAJOR_VERSION=$(MAJORVERSION) -DMINOR_VERSION=$(MINORVERSION) -DPATCH_VERSION=$(PATCHVERSION) -DPRODUCTION_BUILD_PREFIX=$(OSCONFIG_REVISION) -G Ninja -B$(Agent.BuildDirectory) -H.'

# Run CMake to generate Makefile (With test coverage)
- task: CMake@1
  displayName: 'Generate build (with coverage)'
  condition: eq(variables.coverage, true)
  inputs:
    workingDirectory: $(OSCONFIG_SRC)
    cmakeArgs: '-DCMAKE_BUILD_TYPE=Debug -Duse_prov_client=ON -Dhsm_type_symm_key=ON -DCOVERAGE=ON -DCOMPILE_WITH_STRICTNESS=ON -DMAJOR_VERSION=$(MAJORVERSION) -DMINOR_VERSION=$(MINORVERSION) -DPATCH_VERSION=$(PATCHVERSION) -DPRODUCTION_BUILD_PREFIX=$(OSCONFIG_REVISION) -G Ninja -B$(Agent.BuildDirectory) -H.'

# Build project
- task: Bash@3
  displayName: 'Build osconfig'
  inputs:
    workingDirectory: $(Agent.BuildDirectory)
    targetType: 'inline'
    script: 'cmake --build .'

# Create the Deb binary package (.deb)
# Uses CTest to generate Debian package
- task: Bash@3
  displayName: 'Create Deb package'
  condition: eq(variables.coverage, false)
  inputs:
    workingDirectory: $(Agent.BuildDirectory)
    targetType: 'inline'
    script: 'cpack -G DEB'

# Stage the debian and hash as artifacts in a staging directory
- task: Bash@3
  displayName: 'Stage Deb package'
  condition: eq(variables.coverage, false)
  inputs:
    workingDirectory: $(Agent.BuildDirectory)
    targetType: 'inline'
    script: 'cp osconfig_* $(Build.ArtifactStagingDirectory)'

# Published the Deb package
- publish: $(Build.ArtifactStagingDirectory)
  displayName: 'Publishing deb package for $(variant)-$(arch)'
  condition: eq(variables.coverage, false)
  artifact: OSConfig_$(Build.BuildNumber)_$(variant)_$(arch)

# Runs ctest in dashboard mode (-T) which will create a report used below (See `PublishTestResults`)
# Tests by loading a CTestTestfile.cmake from the build tree and executing the defined tests.
# Record the output and result of each test
# See ctest test step - https://cmake.org/cmake/help/latest/manual/ctest.1.html#ctest-test-step
- task: Bash@3
  displayName: 'Run tests'
  inputs:
    workingDirectory: $(Agent.BuildDirectory)
    targetType: 'inline'
    script: 'ctest -T test --verbose > TestOutput.log'

# Published the test output from tests - test results above do not contain logs
- publish: $(Agent.BuildDirectory)/TestOutput.log
  condition: and(succeededOrFailed(), eq(variables.coverage, false))
  displayName: 'Publishing TestOutput.log'
  artifact: Test Logs - $(variant)_$(arch)

# Published the test output from tests - test results above do not contain logs
- publish: $(Agent.BuildDirectory)/TestOutput.log
  condition: and(succeededOrFailed(), eq(variables.coverage, true))
  displayName: 'Publishing TestOutput.log'
  artifact: Test Logs - Code Coverage Job

# Publishes the results of the ctest test pass to be used in the ADO dashboard
- task: PublishTestResults@2
  displayName: 'Publish test results'
  condition: and(succeededOrFailed(), eq(variables.coverage, false))
  inputs:
    testRunner: cTest
    testResultsFiles: '$(Agent.BuildDirectory)/Testing/*/Test.xml'
    failTaskOnFailedTests: true
    testRunTitle: $(variant) $(arch)
    platform: $(arch)

# Generates Cobertura styled code coverage results to be consumed below (See `PublishCodeCoverageResults`)
- task: Bash@3
  displayName: 'Run code coverage'
  condition: eq(variables.coverage, true)
  inputs:
    workingDirectory: $(Agent.BuildDirectory)
    targetType: 'inline'
    script: 'gcovr -r $(Build.SourcesDirectory)/src . -e $(Build.SourcesDirectory)/src/agents/pnp/azure-iot-sdk-c/ -e $(Build.SourcesDirectory)/src/agents/pnp/tracelogging/ --xml coverage.xml'

# Needed for the code coverage report task below (See `PublishCodeCoverageResults`)
- task: UseDotNet@2
  displayName: 'Use .NET Core sdk'
  condition: eq(variables.coverage, true)
  inputs:
    packageType: sdk
    version: 3.1.402
    installationPath: $(Agent.ToolsDirectory)/dotnet

# Publish code coverage results
- task: PublishCodeCoverageResults@1
  displayName: 'Publish code coverage results'
  condition: eq(variables.coverage, true)
  inputs:
    codeCoverageTool: 'Cobertura'
    summaryFileLocation: $(Agent.BuildDirectory)/coverage.xml
    pathToSources: $(Build.SourcesDirectory)/src
    #failIfCoverageEmpty: false # Optional

# Delete files - (Necessary for self-hosted agents)
- script: |
    rm -rf $(Build.SourcesDirectory)/*
  displayName: Removing sources
  continueOnError: true